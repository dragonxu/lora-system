{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Overview What is LoRa\u2122 & LoRaWAN\u2122 LoRa\u2122 Long Range (LoRa\u2122) is one of the most promising wireless data communication technologies designed for low-power Internet of things (IoT) devices to achieve long-range transmission. LoRa\u2122 consists of two main parts, i.e., LoRa\u2122 and LoRaWAN\u2122. LoRa\u2122 is the physical layer and defines a kind of wireless modulation over a license-free frequency band. This kind of spread spectrum modulation technique is improved from chirp spread spectrum (CSS) technology. It can increase the communication range significantly while keeping the same low-power characteristics as Frequency Shift Keying (FSK). LoRaWAN\u2122 defines the upper layer of LoRa\u2122 and is discussed below. LoRaWAN\u2122 The LoRaWAN\u2122 specification is a Low Power Wide Area networking (LPWAN) protocol based on LoRa\u2122 technology. This specification is released by LoRa Alliance\u2122. It describes the communication and system architecture for LoRa networks. LoRaWAN network architecture is designed as a star-of-stars topology in which end-devices send messages to the central network server through the gateways. What is X-LoRa System FleXsible LoRa (X-LoRa) system project is designed for building LoRaWAN networks which is hosted on the GitHub platform. The system is used to manage and aggregate the gateways, the applications and the devices. It receives messages from gateways and send the data to the applications. The project provides a ready-to-use solution for users including web-interface and HTTP APIs. For example, Application server manages application payloads and web management server offers a UI interface for users to access and modify their gateways, applications and devices. Furthermore, the HTTP APIs are designed so that the LoRa system may be integrated into other platforms. A complete LoRa network is composed of several parts, i.e., LoRa device, LoRa gateway and LoRa system. The X-LoRa system is proposed to facilitate the implementation and management of private LoRa networks. X-LoRa consists of four modules, which are responsible for different tasks and services such as protocol processing and device activation. Application server is designed to customize the structure and encryption of various application payload. The web project makes it easy for administrators to manage LoRa devices and various applications. The implementation details of X-LoRa system are described below, as well as the tutorials for deploying and using such a system. Architecture Our X-LoRa System consists of six main components: Connector Server Join Server Controller Application Server Web management server Connector is the bridge between the LoRa gateway and Server, which provides the services for parsing and packaging the payload of Media Access Control (MAC) layer. Server is responsible for data management and service scheduling. Join Server is proposed to handle the activation requests of LoRa devices. Controller focuses on processing and managing MAC commands exchanged between LoRa server and LoRa devices in order to adjust LoRa\u2122 transmission parameters. Application Server is responsible for the handling, encryption and decryption of application payloads. Web management server is designed as a user interface that allows for easy management of applications and devices via a web browser. Features High Performance X-LoRa system can reach a very high performance on concurrency and latency. The whole system is developed in Node.js which is expert in asynchronous I/O, making it fast to handle thousands of requests concurrently. Scalability X-LoRa uses message queue to unite each component. Therefore, it can be easily scaled up by adding devices to the clusters to deal with growing size. Open Source X-LoRa system is totally open source and hosted on Github under license GPL-3.0. Welcome to make contributions and feel free to use X-LoRa anywhere you like. Gateway Routing X-LoRa server manages routing of downlink messages in order to ensure that the gateway which has the best channel quality with target device can be assigned to forward the messages. Adaptive Data Rate An efficient ADR scheme is deployed in X-LoRa, which is proposed in LoRaWAN\u2122 specification. The ADR scheme running on Controller is responsible for controlling the data rate and transmission power of LoRa devices, so that they can ensure the successful transmission of packets while reducing the energy consumption. Enabling ADR scheme can significantly improve spectrum utilization and the battery lifetime of LoRa devices. Of course, LoRa devices can choose whether to turn this mechanism on or not by the ADR flag bit of the uplink packet. In addition, the ADR scheme only applies to stationary LoRa devices because it may not be possible when the radio channel attenuation changes fast and constantly. Customizable Each of the component of X-LoRa system can be customized as long as the format of messages are matched. Application Integration and APIs The application data is published to the message queue on a certain topic. Therefore, external applications can be integrated to X-LoRa by subscribing the topic. Besides, X-LoRa provides a bunch of HTTP APIs to enable service integration.","title":"Overview"},{"location":"#overview","text":"","title":"Overview"},{"location":"#what-is-loratm-lorawantm","text":"","title":"What is LoRa\u2122 &amp; LoRaWAN\u2122"},{"location":"#loratm","text":"Long Range (LoRa\u2122) is one of the most promising wireless data communication technologies designed for low-power Internet of things (IoT) devices to achieve long-range transmission. LoRa\u2122 consists of two main parts, i.e., LoRa\u2122 and LoRaWAN\u2122. LoRa\u2122 is the physical layer and defines a kind of wireless modulation over a license-free frequency band. This kind of spread spectrum modulation technique is improved from chirp spread spectrum (CSS) technology. It can increase the communication range significantly while keeping the same low-power characteristics as Frequency Shift Keying (FSK). LoRaWAN\u2122 defines the upper layer of LoRa\u2122 and is discussed below.","title":"LoRa\u2122"},{"location":"#lorawantm","text":"The LoRaWAN\u2122 specification is a Low Power Wide Area networking (LPWAN) protocol based on LoRa\u2122 technology. This specification is released by LoRa Alliance\u2122. It describes the communication and system architecture for LoRa networks. LoRaWAN network architecture is designed as a star-of-stars topology in which end-devices send messages to the central network server through the gateways.","title":"LoRaWAN\u2122"},{"location":"#what-is-x-lora-system","text":"FleXsible LoRa (X-LoRa) system project is designed for building LoRaWAN networks which is hosted on the GitHub platform. The system is used to manage and aggregate the gateways, the applications and the devices. It receives messages from gateways and send the data to the applications. The project provides a ready-to-use solution for users including web-interface and HTTP APIs. For example, Application server manages application payloads and web management server offers a UI interface for users to access and modify their gateways, applications and devices. Furthermore, the HTTP APIs are designed so that the LoRa system may be integrated into other platforms. A complete LoRa network is composed of several parts, i.e., LoRa device, LoRa gateway and LoRa system. The X-LoRa system is proposed to facilitate the implementation and management of private LoRa networks. X-LoRa consists of four modules, which are responsible for different tasks and services such as protocol processing and device activation. Application server is designed to customize the structure and encryption of various application payload. The web project makes it easy for administrators to manage LoRa devices and various applications. The implementation details of X-LoRa system are described below, as well as the tutorials for deploying and using such a system.","title":"What is X-LoRa System"},{"location":"#architecture","text":"Our X-LoRa System consists of six main components: Connector Server Join Server Controller Application Server Web management server Connector is the bridge between the LoRa gateway and Server, which provides the services for parsing and packaging the payload of Media Access Control (MAC) layer. Server is responsible for data management and service scheduling. Join Server is proposed to handle the activation requests of LoRa devices. Controller focuses on processing and managing MAC commands exchanged between LoRa server and LoRa devices in order to adjust LoRa\u2122 transmission parameters. Application Server is responsible for the handling, encryption and decryption of application payloads. Web management server is designed as a user interface that allows for easy management of applications and devices via a web browser.","title":"Architecture"},{"location":"#features","text":"High Performance X-LoRa system can reach a very high performance on concurrency and latency. The whole system is developed in Node.js which is expert in asynchronous I/O, making it fast to handle thousands of requests concurrently. Scalability X-LoRa uses message queue to unite each component. Therefore, it can be easily scaled up by adding devices to the clusters to deal with growing size. Open Source X-LoRa system is totally open source and hosted on Github under license GPL-3.0. Welcome to make contributions and feel free to use X-LoRa anywhere you like. Gateway Routing X-LoRa server manages routing of downlink messages in order to ensure that the gateway which has the best channel quality with target device can be assigned to forward the messages. Adaptive Data Rate An efficient ADR scheme is deployed in X-LoRa, which is proposed in LoRaWAN\u2122 specification. The ADR scheme running on Controller is responsible for controlling the data rate and transmission power of LoRa devices, so that they can ensure the successful transmission of packets while reducing the energy consumption. Enabling ADR scheme can significantly improve spectrum utilization and the battery lifetime of LoRa devices. Of course, LoRa devices can choose whether to turn this mechanism on or not by the ADR flag bit of the uplink packet. In addition, the ADR scheme only applies to stationary LoRa devices because it may not be possible when the radio channel attenuation changes fast and constantly. Customizable Each of the component of X-LoRa system can be customized as long as the format of messages are matched. Application Integration and APIs The application data is published to the message queue on a certain topic. Therefore, external applications can be integrated to X-LoRa by subscribing the topic. Besides, X-LoRa provides a bunch of HTTP APIs to enable service integration.","title":"Features"},{"location":"Source&Contact/","text":"Source & Contact Github This repo is hosted on https://github.com/xisiot/lora-system and under GPL-3.0 License , any contribution or suggestion is welcome. Just open an issue or send a pull request. Contact Us","title":"Source&Contact"},{"location":"Source&Contact/#source-contact","text":"","title":"Source &amp; Contact"},{"location":"Source&Contact/#github","text":"This repo is hosted on https://github.com/xisiot/lora-system and under GPL-3.0 License , any contribution or suggestion is welcome. Just open an issue or send a pull request.","title":"Github"},{"location":"Source&Contact/#contact-us","text":"","title":"Contact Us"},{"location":"Implementations/Connector/","text":"Connector The LoRa network connector serves as the entrance of the whole X-LoRa system. Functions Gateway Connections LoRa gateways directly connect to LoRa network connector and upload and download data for LoRa devices. The format of packages follows the Gateway to Server Interface Definition by Semtech\u2122 Corporation, which can be referred in Interaction with LoRa Gateways Section . The communications are carried on UDP. Connector will record two UDP ports for gateways separately, i.e., pull port and push port , after receiving corresponding type of data. Further downlink data is sent to the matching port. Package Encapsulation and De-capsulation One of the main jobs of LoRa network connector is to parse and encapsulate packages received from LoRa Gateways. Data from LoRa devices are kept in data field as an array in gateway packages. These data are byte sequences originally and encoded in base64 format before uploading. The illustration below shows how the data of devices are packaged. After receiving packages from gateways, connector needs to extract device data from data field and decode each element with base64. Then, each data is parsed by bytes according to the message type that is come up with the MHDR field. All message types defined in LoRaWAN\u2122 1.1 are well supported. After each field is sliced, some necessary verifications are conducted, as well as decryption, which can be referred at following paragraphs. When everything\u2019s fine, the message is published to the message queue on topic NC-pub for those subscribers interested. The message format is defined in Interaction with LoRa Server Section . The LoRa network connector has also subscribed a topic named NC-sub where it can receive downlink messages for LoRa devices and encapsulate them to byte sequences. During this process, the messages are encrypted and the MIC is calculated. Then, the messages are encoded by base64 and inserted into the data field of the JSON document for gateways. This kind of messages is called PULL_RESP , and forwarded to the pull port of gateways over UDP. Verification LoRa network connector is responsible for necessary message verifications and prevent illegal messages from entering the systems. All checks are listed below for clarity. Item Further Description Action MIC Mismatch Data corruption Discard Identify Error Device or gateway does not exist Discard Illegal Format Message is not assembled in standard way Discard Out of Boundary Data exceed the maximum length Discard FCnt Error The count of message frames is discordant Discard or Ignore Security LoRa network connector needs to encrypt and decrypt data to ensure privacy. The detailed processes of encryption and decryption can be found in LoRaWAN\u2122 1.0.2 standard. Connector is strictly stick to the standard to guarantee it accordance. Devices must make sure the root key AppKey is carefully saved in their hardware. On the other hand, the transmission between gateways and connector is transparent, which could bring security vulnerabilities. This can be fixed by conducting secured version of UDP (such as DTLS where TLS is used in UDP) both in connector side and gateway sides. Load Balancing, Availablity and Throttling LoRa network connector has also considered the performance since it is the entrance of the backend servers. Load balancing can be applied by deploying multiple connectors and proper schedule algorithms. The availability, in this way, is also kept. Throttling is required in connector to keep the vicious data flood out of the house. Interaction with LoRa Gateways The LoRa network connector interacts with LoRa gateways with six types of messages in total. The detailed format can be learned from the open documents of Semtech\u2122 Corporation. Here, we only give some brief instructions. The following three messages are sent from gateway to connector . PULL_DATA This message should be sent periodically by gateways to inform connector that the current gateway is alive. Besides, the UDP port gateway used to send PULL_DATA is recorded as pull port . PUSH_DATA This message contains a JSON object where three main kinds of data, i.e., the status of gateway itself, the status of LoRa device and the uplink data. The key names are stat , rxpk and data (inside rxpk field), respectively. The rxpk field is defined as an array so that it can contain multiple messages from different devices. This JSON object is serialized with ASCII-only characters and must not exceed 2048 octets. An example JSON object is listed below, which contains a stat field and one rxpk field. { rxpk: [ { tmst: 1545034506, chan: 7, rfch: 0, freq: 435.9, stat: 1, modu: 'LORA', datr: 'SF12BW125', codr: '4/5', lsnr: 2, rssi: -119, size: 24, data: 'gJbhkgAgTQCw9hsOerYkPu9D' } ], stat: { time: '2018-12-17 16:15:06 GMT', rxnb: 1, rxok: 0, rxfw: 0, ackr: 100, dwnb: 0, txnb: 0 } } The UDP port used by PUSH_DATA will be marked as push port in connector. TX_ACK This message is used to acknowledge the connector that the PULL_RESP (will be described below) message is received and some (maybe no) errors occurred. The following three kinds of messages are sent from connector to gateways . PULL_ACK This is to acknowledge the gateways that the PULL_DATA is successfully received. PUSH_ACK This is to acknowledge the gateways that the PUSH_DATA is successfully received. PULL_RESP This kind of message is used for connector to send downlink message to gateways. It has a similar structure as rxpk except that the key name of JSON object is changed to txpk and the total length cannot exceed 1000 octets. An example PULL_RESP message is shown as follow, {\u2018txpk\u2019: {'codr': '4/5', 'data': 'oJbhkgCjfwcGBgaWMvobrA==', 'datr': 'SF12BW125', 'freq': 435.9, 'imme': False, 'ipol': False, 'modu': 'LORA', 'powe': 25, 'rfch': 0, 'size': 16, 'tmst': 1546035144} } The PULL_RESP is sent to the gateway through pull_port . Therefore, gateways MUST send PULL_DATA before any PULL_RESP can be received. Interaction with LoRa Server The connector publishes its uplink data to message queue and receive downlink data from it. In our X-LoRa system, the LoRa network server is responsible for direct interaction with connector. Therefore, network server will subscribe topic NC-pub and publish data on topic NC-sub . The data exchange format between connector and network server is defined in this section. Connect to Network Server Connector needs to upload all necessary and plain data to network server for further processing. In order to ensure consistency, the data format is designed the same as the LoRaWAN\u2122 MAC payloads with each field parsed and pre-processed. On the other hand, the meta data ( stat and rxpk ) will also be sent without any changes. The example JSON format of an uplink message from connector is shown below, { version: <Buffer 02>, token: <Buffer 93 b9>, identifier: <Buffer 00>, gatewayId: <Buffer 00 00 00 00 00 00 00 00>, stat: { time: '2018-12-17 16:43:16 GMT', rxnb: 1, rxok: 0, rxfw: 0, ackr: 100, dwnb: 0, txnb: 0 }, rxpk: [ { tmst: 1545036196, chan: 7, rfch: 0, freq: 435.9, stat: 1, modu: 'LORA', datr: 'SF12BW125', codr: '4/5', lsnr: 2, rssi: -119, size: 24, data: { MHDR: { MType: 4, Major: 0 }, MACPayload: { FHDR: { DevAddr: <Buffer 00 92 e1 96>, FCtrl: { ADR: 0, ADRACKReq: 0, ACK: 1, ClassB: 0, FOptsLen: 0 }, FCnt: <Buffer 00 00 00 53>, FOpts: [ ] }, FPort: <Buffer d2>, FRMPayload: <Buffer 68 65 6c 6c 6f> }, }, raw: 'gJbhkgAgUwDSxFa50NDuZxdj' }, ] } Network Server to Connector The downlink data from network server to connector follows the same pattern so that here only gives an example for reference, { version: <Buffer 02>, token: <Buffer 3e 7d>, identifier: <Buffer 03>, gatewayId: <Buffer 00 00 00 00 00 00 00 00>, txpk: { imme: false, tmst: 1546036645, freq: 435.9, rfch: 0, powe: 25, datr: 'SF12BW125', modu: 'LORA', codr: '4/5', ipol: false, data: { MHDR: { MType: 5, Major: 0 }, MACPayload: { FHDR: { DevAddr: <Buffer 00 92 e1 96>, FCtrl: { ACK: 1, ADR: true, FPending: 0, FOptsLen: 3 }, FCnt: <Buffer 00 00 07 85>, FOpts: [ { '06': {} }, { '06': {} }, { '06': {} },] }, FPort: <Buffer e6> } } } }","title":"Connector"},{"location":"Implementations/Connector/#connector","text":"The LoRa network connector serves as the entrance of the whole X-LoRa system.","title":"Connector"},{"location":"Implementations/Connector/#functions","text":"Gateway Connections LoRa gateways directly connect to LoRa network connector and upload and download data for LoRa devices. The format of packages follows the Gateway to Server Interface Definition by Semtech\u2122 Corporation, which can be referred in Interaction with LoRa Gateways Section . The communications are carried on UDP. Connector will record two UDP ports for gateways separately, i.e., pull port and push port , after receiving corresponding type of data. Further downlink data is sent to the matching port. Package Encapsulation and De-capsulation One of the main jobs of LoRa network connector is to parse and encapsulate packages received from LoRa Gateways. Data from LoRa devices are kept in data field as an array in gateway packages. These data are byte sequences originally and encoded in base64 format before uploading. The illustration below shows how the data of devices are packaged. After receiving packages from gateways, connector needs to extract device data from data field and decode each element with base64. Then, each data is parsed by bytes according to the message type that is come up with the MHDR field. All message types defined in LoRaWAN\u2122 1.1 are well supported. After each field is sliced, some necessary verifications are conducted, as well as decryption, which can be referred at following paragraphs. When everything\u2019s fine, the message is published to the message queue on topic NC-pub for those subscribers interested. The message format is defined in Interaction with LoRa Server Section . The LoRa network connector has also subscribed a topic named NC-sub where it can receive downlink messages for LoRa devices and encapsulate them to byte sequences. During this process, the messages are encrypted and the MIC is calculated. Then, the messages are encoded by base64 and inserted into the data field of the JSON document for gateways. This kind of messages is called PULL_RESP , and forwarded to the pull port of gateways over UDP. Verification LoRa network connector is responsible for necessary message verifications and prevent illegal messages from entering the systems. All checks are listed below for clarity. Item Further Description Action MIC Mismatch Data corruption Discard Identify Error Device or gateway does not exist Discard Illegal Format Message is not assembled in standard way Discard Out of Boundary Data exceed the maximum length Discard FCnt Error The count of message frames is discordant Discard or Ignore Security LoRa network connector needs to encrypt and decrypt data to ensure privacy. The detailed processes of encryption and decryption can be found in LoRaWAN\u2122 1.0.2 standard. Connector is strictly stick to the standard to guarantee it accordance. Devices must make sure the root key AppKey is carefully saved in their hardware. On the other hand, the transmission between gateways and connector is transparent, which could bring security vulnerabilities. This can be fixed by conducting secured version of UDP (such as DTLS where TLS is used in UDP) both in connector side and gateway sides. Load Balancing, Availablity and Throttling LoRa network connector has also considered the performance since it is the entrance of the backend servers. Load balancing can be applied by deploying multiple connectors and proper schedule algorithms. The availability, in this way, is also kept. Throttling is required in connector to keep the vicious data flood out of the house.","title":"Functions"},{"location":"Implementations/Connector/#interaction-with-lora-gateways","text":"The LoRa network connector interacts with LoRa gateways with six types of messages in total. The detailed format can be learned from the open documents of Semtech\u2122 Corporation. Here, we only give some brief instructions. The following three messages are sent from gateway to connector . PULL_DATA This message should be sent periodically by gateways to inform connector that the current gateway is alive. Besides, the UDP port gateway used to send PULL_DATA is recorded as pull port . PUSH_DATA This message contains a JSON object where three main kinds of data, i.e., the status of gateway itself, the status of LoRa device and the uplink data. The key names are stat , rxpk and data (inside rxpk field), respectively. The rxpk field is defined as an array so that it can contain multiple messages from different devices. This JSON object is serialized with ASCII-only characters and must not exceed 2048 octets. An example JSON object is listed below, which contains a stat field and one rxpk field. { rxpk: [ { tmst: 1545034506, chan: 7, rfch: 0, freq: 435.9, stat: 1, modu: 'LORA', datr: 'SF12BW125', codr: '4/5', lsnr: 2, rssi: -119, size: 24, data: 'gJbhkgAgTQCw9hsOerYkPu9D' } ], stat: { time: '2018-12-17 16:15:06 GMT', rxnb: 1, rxok: 0, rxfw: 0, ackr: 100, dwnb: 0, txnb: 0 } } The UDP port used by PUSH_DATA will be marked as push port in connector. TX_ACK This message is used to acknowledge the connector that the PULL_RESP (will be described below) message is received and some (maybe no) errors occurred. The following three kinds of messages are sent from connector to gateways . PULL_ACK This is to acknowledge the gateways that the PULL_DATA is successfully received. PUSH_ACK This is to acknowledge the gateways that the PUSH_DATA is successfully received. PULL_RESP This kind of message is used for connector to send downlink message to gateways. It has a similar structure as rxpk except that the key name of JSON object is changed to txpk and the total length cannot exceed 1000 octets. An example PULL_RESP message is shown as follow, {\u2018txpk\u2019: {'codr': '4/5', 'data': 'oJbhkgCjfwcGBgaWMvobrA==', 'datr': 'SF12BW125', 'freq': 435.9, 'imme': False, 'ipol': False, 'modu': 'LORA', 'powe': 25, 'rfch': 0, 'size': 16, 'tmst': 1546035144} } The PULL_RESP is sent to the gateway through pull_port . Therefore, gateways MUST send PULL_DATA before any PULL_RESP can be received.","title":"Interaction with LoRa Gateways"},{"location":"Implementations/Connector/#interaction-with-lora-server","text":"The connector publishes its uplink data to message queue and receive downlink data from it. In our X-LoRa system, the LoRa network server is responsible for direct interaction with connector. Therefore, network server will subscribe topic NC-pub and publish data on topic NC-sub . The data exchange format between connector and network server is defined in this section. Connect to Network Server Connector needs to upload all necessary and plain data to network server for further processing. In order to ensure consistency, the data format is designed the same as the LoRaWAN\u2122 MAC payloads with each field parsed and pre-processed. On the other hand, the meta data ( stat and rxpk ) will also be sent without any changes. The example JSON format of an uplink message from connector is shown below, { version: <Buffer 02>, token: <Buffer 93 b9>, identifier: <Buffer 00>, gatewayId: <Buffer 00 00 00 00 00 00 00 00>, stat: { time: '2018-12-17 16:43:16 GMT', rxnb: 1, rxok: 0, rxfw: 0, ackr: 100, dwnb: 0, txnb: 0 }, rxpk: [ { tmst: 1545036196, chan: 7, rfch: 0, freq: 435.9, stat: 1, modu: 'LORA', datr: 'SF12BW125', codr: '4/5', lsnr: 2, rssi: -119, size: 24, data: { MHDR: { MType: 4, Major: 0 }, MACPayload: { FHDR: { DevAddr: <Buffer 00 92 e1 96>, FCtrl: { ADR: 0, ADRACKReq: 0, ACK: 1, ClassB: 0, FOptsLen: 0 }, FCnt: <Buffer 00 00 00 53>, FOpts: [ ] }, FPort: <Buffer d2>, FRMPayload: <Buffer 68 65 6c 6c 6f> }, }, raw: 'gJbhkgAgUwDSxFa50NDuZxdj' }, ] } Network Server to Connector The downlink data from network server to connector follows the same pattern so that here only gives an example for reference, { version: <Buffer 02>, token: <Buffer 3e 7d>, identifier: <Buffer 03>, gatewayId: <Buffer 00 00 00 00 00 00 00 00>, txpk: { imme: false, tmst: 1546036645, freq: 435.9, rfch: 0, powe: 25, datr: 'SF12BW125', modu: 'LORA', codr: '4/5', ipol: false, data: { MHDR: { MType: 5, Major: 0 }, MACPayload: { FHDR: { DevAddr: <Buffer 00 92 e1 96>, FCtrl: { ACK: 1, ADR: true, FPending: 0, FOptsLen: 3 }, FCnt: <Buffer 00 00 07 85>, FOpts: [ { '06': {} }, { '06': {} }, { '06': {} },] }, FPort: <Buffer e6> } } } }","title":"Interaction with LoRa Server"},{"location":"Implementations/Controller/","text":"Controller The LoRa network controller focuses on processing and managing MAC commands, which are used to modify associated con\ufb01gurations or adjust transmission parameters in physical layer. Functions The LoRa network controller implements the analysis of the uplink MAC Commands, performs corresponding algorithms, and generates the downlink MAC Commands which may be sent within the downlink packet or individually. MAC Command Queue For each end-device, the LoRa network controller maintains a MAC Command queue with each element in the queue as shown in the following table. Field Description CID MAC Command ID Payload Byte sequence that Command may contain MAC Command Alogorithm The step one starts as soon as the uplink packet arrives, and step one to step nine is continuous cycling. Once the uplink data arrives, if the packet contains the MAC Command, the LoRa Network Server extracts the part and sends it to the Network Controller by an array; The LoRa Network Controller will read all the commands in the MAC Command Request Queue, and put them into the array Q, then traverse the array Q, then delete all data in the MAC Command Answer Queue; The MAC Command in the data packet which the Network Controller receives contains answers and requests, and the Network Controller will traverse all the data packet; When Encountering MAC Command answer, the Network Controller will compare it with the array Q, and record the position of the first unmatched answer-request pair as d; When Encountering MAC Command request, the Network Controller will process it; Clear the original MAC Command Request Queue, and push all elements of array Q from position d into the new MAC Command Request Queue; Traverse MAC Command Request Queue and application data Queue; Construct downlink data according to the following table policy and send it to the Network Connector by Network Server; The Network Connector encapsulates the LoRa packet and delivers it to the gateway. Downlink MAC Command and Application Data Group Package Policy Downlink Application Data Downlink MAC Commands Send Downlink Packet FOpts FRMPayload Other Not Available Not Available No - - - Is Available Not Available Yes Null Application Data - Not Available Is Available (> 15 bytes) Yes Null MAC FPort = 0 Not Available Is Available (<= 15 bytes) Yes MAC Null - Is Available Is Available (> 15 bytes) Yes Null MAC FPort = 0 FPending = 1 Is Available Is Available (<= 15 bytes) Yes Null Application Data - Interaction with LoRa Nework Server The LoRa join server subscribes the topic CS-sub to receive join requests from LoRa network server, and publishes join accept on topic CS-pub to LoRa network server. Network Server to Network Controller { DevAddr: <Buffer 00 96 44 72>, data: [ { 0x01: { Version: <Buffer 02>, }, }, { 0x02: null, }, { 0x03: { \"Status\": <Buffer 02>, }, }, ], adr: true, devtx: { \"freq\": 433.3, \"datr\": \"SF7BW125\", \"codr\": \"4/6\", }, gwrx: [ { gatewayId: <Buffer b8 27 eb ff fe 52 0e 51>, time: \"2013-03-31T16:21:17.528002Z\", tmst: 3512348611, chan: 2, rfch: 0, stat: 1, modu: \"LORA\", rssi: -35, lsnr: 5.1, size: 32, }, ], } Network Controller to Network Server { \"cid\": \"payload\", } Example: { 0x01: { \"Version\": <Buffer 02>, }, }","title":"Controller"},{"location":"Implementations/Controller/#controller","text":"The LoRa network controller focuses on processing and managing MAC commands, which are used to modify associated con\ufb01gurations or adjust transmission parameters in physical layer.","title":"Controller"},{"location":"Implementations/Controller/#functions","text":"The LoRa network controller implements the analysis of the uplink MAC Commands, performs corresponding algorithms, and generates the downlink MAC Commands which may be sent within the downlink packet or individually.","title":"Functions"},{"location":"Implementations/Controller/#mac-command-queue","text":"For each end-device, the LoRa network controller maintains a MAC Command queue with each element in the queue as shown in the following table. Field Description CID MAC Command ID Payload Byte sequence that Command may contain","title":"MAC Command Queue"},{"location":"Implementations/Controller/#mac-command-alogorithm","text":"The step one starts as soon as the uplink packet arrives, and step one to step nine is continuous cycling. Once the uplink data arrives, if the packet contains the MAC Command, the LoRa Network Server extracts the part and sends it to the Network Controller by an array; The LoRa Network Controller will read all the commands in the MAC Command Request Queue, and put them into the array Q, then traverse the array Q, then delete all data in the MAC Command Answer Queue; The MAC Command in the data packet which the Network Controller receives contains answers and requests, and the Network Controller will traverse all the data packet; When Encountering MAC Command answer, the Network Controller will compare it with the array Q, and record the position of the first unmatched answer-request pair as d; When Encountering MAC Command request, the Network Controller will process it; Clear the original MAC Command Request Queue, and push all elements of array Q from position d into the new MAC Command Request Queue; Traverse MAC Command Request Queue and application data Queue; Construct downlink data according to the following table policy and send it to the Network Connector by Network Server; The Network Connector encapsulates the LoRa packet and delivers it to the gateway. Downlink MAC Command and Application Data Group Package Policy Downlink Application Data Downlink MAC Commands Send Downlink Packet FOpts FRMPayload Other Not Available Not Available No - - - Is Available Not Available Yes Null Application Data - Not Available Is Available (> 15 bytes) Yes Null MAC FPort = 0 Not Available Is Available (<= 15 bytes) Yes MAC Null - Is Available Is Available (> 15 bytes) Yes Null MAC FPort = 0 FPending = 1 Is Available Is Available (<= 15 bytes) Yes Null Application Data -","title":"MAC Command Alogorithm"},{"location":"Implementations/Controller/#interaction-with-lora-nework-server","text":"The LoRa join server subscribes the topic CS-sub to receive join requests from LoRa network server, and publishes join accept on topic CS-pub to LoRa network server. Network Server to Network Controller { DevAddr: <Buffer 00 96 44 72>, data: [ { 0x01: { Version: <Buffer 02>, }, }, { 0x02: null, }, { 0x03: { \"Status\": <Buffer 02>, }, }, ], adr: true, devtx: { \"freq\": 433.3, \"datr\": \"SF7BW125\", \"codr\": \"4/6\", }, gwrx: [ { gatewayId: <Buffer b8 27 eb ff fe 52 0e 51>, time: \"2013-03-31T16:21:17.528002Z\", tmst: 3512348611, chan: 2, rfch: 0, stat: 1, modu: \"LORA\", rssi: -35, lsnr: 5.1, size: 32, }, ], } Network Controller to Network Server { \"cid\": \"payload\", } Example: { 0x01: { \"Version\": <Buffer 02>, }, }","title":"Interaction with LoRa Nework Server"},{"location":"Implementations/Join/","text":"Join Server The LoRa join server handles the registrations of LoRa devices according to LoRaWAN\u2122 standard. OTAA vs ABP LoRaWAN\u2122 standard defines two ways of activation for LoRa devices, i.e., Over-The-Air Activation (OTAA) and Activation by Personalization (ABP). All LoRa devices must be activated in either way before access the network. In OTAA mode, LoRa devices only need to store AppEUI, DevEUI (or JoinEUI in LoRaWAN\u2122 standard 1.1) and AppKey in their hardware. Then, these devices can issue activations by sending join request messages to servers. Some necessary parameters will be generated by server and respond via join accept messages. Some other data (e.g. session keys) are generated by both devices and server. These data are coincident since they use the same arguments and algorithms. In ABP mode, all the necessary information is loaded in devices in the very beginning. These devices can interact with connector directly. Some previous operations need to be taken before enabling OTAA or adopting ABP to devices, please refer to Section 3.3.2 for more information. Functions Activation LoRa join server is only responsible for handling devices with OTAA mode. The ABP based devices can access the network directly. The join requests are parsed by connector first. Then, network server will forward the requests to join server via message queue under topic Join-sub. After receiving the requests, join server will generate some necessary data such as the unique identifier DevAddr for devices. The DevAddr contains the NetID for purpose of roaming. Two session keys, i.e., NwkSKey and AppSKey, are also calculated according to the protocol. Another part of the join procedure is to initialize some physical parameters of devices. The RX1DRoffset defines the offset between uplink data rate and downlink data rate at first reception slot. The Rx2 Data rate sets the data rate for second reception slot. Furthermore, the RxDelay configures the delay between TX and first reception slot. The scope of RxDelay varies from 0s to 15s. The details can be found in RXTimingSetupReq command. All these values are region specific and set to their default values during activation. Join server also needs to generate join accept messages for responses. These messages are published on topic Join-pub and network server needs to get them generally. Rejoin UNIMPLEMENTED Interaction with LoRa Network Server The LoRa join server subscribes the topic Join-sub to receive join requests from LoRa network server, and publishes join accept on topic Join-pub to LoRa network server. Network Server to Join Server { MHDR: { MType: 0, Major: 0 }, MACPayload: { AppEUI: <Buffer 7b 80 60 6c af eb 0f 26>, DevEUI: <Buffer 37 b8 90 3b 37 b8 90 3b>, DevNonce: <Buffer 81 bf>, }, }, Join Server to Network Server { MHDR: { MType: 1, Major: 0 }, MACPayload: { AppNonce: <Buffer 32 dc 97>, NetID: <Buffer 00 00 00>, DevAddr: <Buffer 00 92 e1 96>, DLSettings: <Buffer c0>, RxDelay: <Buffer 01> }, },","title":"Join Server"},{"location":"Implementations/Join/#join-server","text":"The LoRa join server handles the registrations of LoRa devices according to LoRaWAN\u2122 standard.","title":"Join Server"},{"location":"Implementations/Join/#otaa-vs-abp","text":"LoRaWAN\u2122 standard defines two ways of activation for LoRa devices, i.e., Over-The-Air Activation (OTAA) and Activation by Personalization (ABP). All LoRa devices must be activated in either way before access the network. In OTAA mode, LoRa devices only need to store AppEUI, DevEUI (or JoinEUI in LoRaWAN\u2122 standard 1.1) and AppKey in their hardware. Then, these devices can issue activations by sending join request messages to servers. Some necessary parameters will be generated by server and respond via join accept messages. Some other data (e.g. session keys) are generated by both devices and server. These data are coincident since they use the same arguments and algorithms. In ABP mode, all the necessary information is loaded in devices in the very beginning. These devices can interact with connector directly. Some previous operations need to be taken before enabling OTAA or adopting ABP to devices, please refer to Section 3.3.2 for more information.","title":"OTAA vs ABP"},{"location":"Implementations/Join/#functions","text":"Activation LoRa join server is only responsible for handling devices with OTAA mode. The ABP based devices can access the network directly. The join requests are parsed by connector first. Then, network server will forward the requests to join server via message queue under topic Join-sub. After receiving the requests, join server will generate some necessary data such as the unique identifier DevAddr for devices. The DevAddr contains the NetID for purpose of roaming. Two session keys, i.e., NwkSKey and AppSKey, are also calculated according to the protocol. Another part of the join procedure is to initialize some physical parameters of devices. The RX1DRoffset defines the offset between uplink data rate and downlink data rate at first reception slot. The Rx2 Data rate sets the data rate for second reception slot. Furthermore, the RxDelay configures the delay between TX and first reception slot. The scope of RxDelay varies from 0s to 15s. The details can be found in RXTimingSetupReq command. All these values are region specific and set to their default values during activation. Join server also needs to generate join accept messages for responses. These messages are published on topic Join-pub and network server needs to get them generally. Rejoin UNIMPLEMENTED","title":"Functions"},{"location":"Implementations/Join/#interaction-with-lora-network-server","text":"The LoRa join server subscribes the topic Join-sub to receive join requests from LoRa network server, and publishes join accept on topic Join-pub to LoRa network server. Network Server to Join Server { MHDR: { MType: 0, Major: 0 }, MACPayload: { AppEUI: <Buffer 7b 80 60 6c af eb 0f 26>, DevEUI: <Buffer 37 b8 90 3b 37 b8 90 3b>, DevNonce: <Buffer 81 bf>, }, }, Join Server to Network Server { MHDR: { MType: 1, Major: 0 }, MACPayload: { AppNonce: <Buffer 32 dc 97>, NetID: <Buffer 00 00 00>, DevAddr: <Buffer 00 92 e1 96>, DLSettings: <Buffer c0>, RxDelay: <Buffer 01> }, },","title":"Interaction with LoRa Network Server"},{"location":"Implementations/Motes/","text":"Motes Emulator This is a useful tool to emulate end devices (a.k.a. Motes) and test LoRa server based on LoRaWAN\u2122 1.0.2 protocol . Requirements Python 3.6 Linux Installation Use pip to install pipenv: (sudo) pip3 install pipenv Clone this repo into a directory: git clone https://github.com/houluy/lora-motes-emulator.git Use pipenv to create a virtual Python enviroment and install all the dependencies: pipenv --python 3 install See the Helps pipenv run python main.py -h or by: pipenv shell python main.py -h Usage This tool can be used step by step as follows, Copy a local config file and device info file from the templates, then modify the src and dest address as the address of test server and LoRa server. Modify device information in device.json you just copied. The information fields include AppEUI , DevEUI , AppKey and GatewayEUI (a.k.a. GatewayID ). Install the tool, and start the virtual shell by command pipenv shell . Totally four kinds of LoRa messages are supported: pull data , join confirmed data up (with or without FOpts ) and MAC Commands in FRMPayload field . The examples are shown below: python main.py pull python main.py join python main.py app -m (your uplink message, will be encoded by UTF-8) -f (your MACCommand in FOpts field) python main.py mac -c (your MAC Command in FRMPayload field) If this is your first-time running, run pull and join commands in the very beginning to register the port of gateway and the LoRa device. The device info will be saved automatically in models/device.pkl using pickle , and loaded next time. Then, you can use app or mac to test your server. Here are the examples. python main.py app -m helloworld -f 0302 python main.py mac -c 0302 Contributions This repo is hosted on https://github.com/houluy/lora-motes-emulator and under MIT license , any contribution or suggestion is welcome. Just open an issue or send a pull request.","title":"Motes Emulator"},{"location":"Implementations/Motes/#motes-emulator","text":"This is a useful tool to emulate end devices (a.k.a. Motes) and test LoRa server based on LoRaWAN\u2122 1.0.2 protocol .","title":"Motes Emulator"},{"location":"Implementations/Motes/#requirements","text":"Python 3.6 Linux","title":"Requirements"},{"location":"Implementations/Motes/#installation","text":"Use pip to install pipenv: (sudo) pip3 install pipenv Clone this repo into a directory: git clone https://github.com/houluy/lora-motes-emulator.git Use pipenv to create a virtual Python enviroment and install all the dependencies: pipenv --python 3 install","title":"Installation"},{"location":"Implementations/Motes/#see-the-helps","text":"pipenv run python main.py -h or by: pipenv shell python main.py -h","title":"See the Helps"},{"location":"Implementations/Motes/#usage","text":"This tool can be used step by step as follows, Copy a local config file and device info file from the templates, then modify the src and dest address as the address of test server and LoRa server. Modify device information in device.json you just copied. The information fields include AppEUI , DevEUI , AppKey and GatewayEUI (a.k.a. GatewayID ). Install the tool, and start the virtual shell by command pipenv shell . Totally four kinds of LoRa messages are supported: pull data , join confirmed data up (with or without FOpts ) and MAC Commands in FRMPayload field . The examples are shown below: python main.py pull python main.py join python main.py app -m (your uplink message, will be encoded by UTF-8) -f (your MACCommand in FOpts field) python main.py mac -c (your MAC Command in FRMPayload field) If this is your first-time running, run pull and join commands in the very beginning to register the port of gateway and the LoRa device. The device info will be saved automatically in models/device.pkl using pickle , and loaded next time. Then, you can use app or mac to test your server. Here are the examples. python main.py app -m helloworld -f 0302 python main.py mac -c 0302","title":"Usage"},{"location":"Implementations/Motes/#contributions","text":"This repo is hosted on https://github.com/houluy/lora-motes-emulator and under MIT license , any contribution or suggestion is welcome. Just open an issue or send a pull request.","title":"Contributions"},{"location":"Implementations/Server/","text":"Server The LoRa network server is the core of the whole X-LoRa system. Functions Data Managemrnt and Service Scheduling Server is responsible for data management and service scheduling. It invokes different modules according to the requirements of data processing. Depending on the type of uplink packet, the information in the packet is separated into specific formats. The data about MAC layer control commands is sent to Controller, the original application data is fed into Application Server and the join packets are forwarded to the Join Server without any interpretation. Moreover, Server is required to schedule packet transmissions on the downlink. One of LoRa gateways is selected to send downlink packets through exploiting the uplink transmission parameters such as RSSI and SNR. In addition, Server identifies the contents of downlink packets from two queues, which are responsible for application data and MAC commands. Deduplication Sometimes, LoRa devices may connect with more than one LoRa gateway. Therefore, single packet from a LoRa device is likely to be received by multiple LoRa gateways simultaneously. To avoid the waste of radio resources due to redundancy, Server is essential for filtering duplicate packets. Only one of the duplicate packets is fed into the subsequent processing modules such as Application Server and Controller. However, the transmission information such as SNR attached in the duplicate packets is not discarded and can be used as reference parameters for downlink routing. Finally, historical data is collected and stored in Server. It can provide the possibility for managers to check up the uplink/downlink packets and monitor the running states of LoRa devices and gateways. HTTP APIs The HTTP APIs are used to register and issue downlink MAC Commands. It is convenient for users to manage the system. Furthermore, users can integrate X-LoRa into their own platforms using these HTTP APIs. All HTTP API methods are listed below. User Register Only users who have been registered can use the X-LoRa System. This API is used for user register and returns the userID used for gateway, application and device register. POST /register Request Headers: Content-Type: application/x-www-form-urlencoded Body: { \"email\": \"test@xisiot.com\", \"password\": \"123456\" } Response Body: { \"userID\": \"4c0c99ca5caef7c9f4707d641c726f55\" } User Login This API is used for user login and returns the userID. POST /login Request Headers: Content-Type: application/x-www-form-urlencoded Body: { \"email\": \"test@xisiot.com\", \"password\": \"123456\" } Response Body: { \"userID\": \"4c0c99ca5caef7c9f4707d641c726f55\" } Application Register This API is used for application register. POST /application Request Headers: Content-Type: application/x-www-form-urlencoded Body: { \"userID\": \"4c0c99ca5caef7c9f4707d641c726f55 \", \"AppEUI\": \"9816be466f467a17\", \"name\": \"test\" } Response Body: { \"code\": \"200\", \"message\": \"success\" } Device Register This API is used for device register. POST /device Request Headers: Content-Type: application/x-www-form-urlencoded Body: { \"AppEUI\": \"9816be466f467a17\", \"DevEUI\": \"AAAAAAAAAAAAAAAA\", \"AppKey\": \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" } Response Body: { \"code\": \"200\", \"message\": \"success\" } Gateway Register This API is used for gateway register. POST /gateway Request Headers: Content-Type: application/x-www-form-urlencoded Body: { \"userID\": \"4c0c99ca5caef7c9f4707d641c726f55 \", \"gatewayId\": \"bbbbbbbbbbbbbbbb\" } Response Body: { \"code\": \"200\", \"message\": \"success\" } Issue MAC Commands This API is used to send the downlink MACCommand. POST /maccommand Request Headers: Content-Type: application/x-www-form-urlencoded Body: { \"DevAddr\": \"12345678 \", \"MACCommand\": \"030200ff01\" } Response Body: { \"code\": \"200\", \"message\": \"success\" } MAC Commands All the MAC Commands defined in LoRaWAN\u2122 1.1 are listed below. Bold font means the downlink MAC Commands. Cid MAC Command Payload Length(byte) 0x01 ResetInd Version 1 0x01 ResetConf Version 1 0x02 LinkCheckReq 0 0x02 LinkCheckAns Margin GwCnt 1 1 0x03 LinkADRReq TXPower ChMask Redundancy 1 2 1 0x03 LinkADRAns Status 1 0x04 DutyCycleReq DutyCyclePL 1 0x04 DutyCycleAns 0 0x05 RXParamSetupReq DLSettings Frequency 1 3 0x05 RXParamSetupAns Status 1 0x06 DevStatusReq 0 0x06 DevStatusAns Battery Margin 1 1 0x07 NewChannelReq ChIndex Freq DrRange 1 3 1 0x07 NewChannelAns Status 1 0x08 RXTimingSetupReq Settings 1 0x08 RXTimingSetupAns 0 0x09 TxParamSetupReq DwellTime 1 0x09 TxParamSetupAns 0 0x0A DlChannelReq ChIndex Freq 1 3 0x0A DlChannelAns Status 1 0x0B RekeyInd Version 1 0x0B RekeyConf Version 1 0x0C ADRParamSetupReq ADRParam 1 0x0C ADRParamSetupAns 0 0x0D DeviceTimeReq 0 0x0D DeviceTimeAns Seconds FractionalSec 4 1 0x0E ForceRejoinReq ForceRejoinReq 2 0x0F RejoinParamSetupReq RejoinParamSetupReq 1 0x0F RejoinParamSetupAns Status 1 Error List Code Message 2101 invalid email 2102 invalid password 2103 invalid AppEUI 2104 invalid DevEUI 2105 invalid AppKey 2106 invalid gatewayId 2107 invalid DevAddr 2108 invalid MACCommand 3101 user already registered 3102 user not registered 3103 user password error 3201 application already created 3202 application not created 3301 device already created 3401 gateway already created","title":"Server"},{"location":"Implementations/Server/#server","text":"The LoRa network server is the core of the whole X-LoRa system.","title":"Server"},{"location":"Implementations/Server/#functions","text":"Data Managemrnt and Service Scheduling Server is responsible for data management and service scheduling. It invokes different modules according to the requirements of data processing. Depending on the type of uplink packet, the information in the packet is separated into specific formats. The data about MAC layer control commands is sent to Controller, the original application data is fed into Application Server and the join packets are forwarded to the Join Server without any interpretation. Moreover, Server is required to schedule packet transmissions on the downlink. One of LoRa gateways is selected to send downlink packets through exploiting the uplink transmission parameters such as RSSI and SNR. In addition, Server identifies the contents of downlink packets from two queues, which are responsible for application data and MAC commands. Deduplication Sometimes, LoRa devices may connect with more than one LoRa gateway. Therefore, single packet from a LoRa device is likely to be received by multiple LoRa gateways simultaneously. To avoid the waste of radio resources due to redundancy, Server is essential for filtering duplicate packets. Only one of the duplicate packets is fed into the subsequent processing modules such as Application Server and Controller. However, the transmission information such as SNR attached in the duplicate packets is not discarded and can be used as reference parameters for downlink routing. Finally, historical data is collected and stored in Server. It can provide the possibility for managers to check up the uplink/downlink packets and monitor the running states of LoRa devices and gateways.","title":"Functions"},{"location":"Implementations/Server/#http-apis","text":"The HTTP APIs are used to register and issue downlink MAC Commands. It is convenient for users to manage the system. Furthermore, users can integrate X-LoRa into their own platforms using these HTTP APIs. All HTTP API methods are listed below.","title":"HTTP APIs"},{"location":"Implementations/Server/#user-register","text":"Only users who have been registered can use the X-LoRa System. This API is used for user register and returns the userID used for gateway, application and device register. POST /register Request Headers: Content-Type: application/x-www-form-urlencoded Body: { \"email\": \"test@xisiot.com\", \"password\": \"123456\" } Response Body: { \"userID\": \"4c0c99ca5caef7c9f4707d641c726f55\" }","title":"User Register"},{"location":"Implementations/Server/#user-login","text":"This API is used for user login and returns the userID. POST /login Request Headers: Content-Type: application/x-www-form-urlencoded Body: { \"email\": \"test@xisiot.com\", \"password\": \"123456\" } Response Body: { \"userID\": \"4c0c99ca5caef7c9f4707d641c726f55\" }","title":"User Login"},{"location":"Implementations/Server/#application-register","text":"This API is used for application register. POST /application Request Headers: Content-Type: application/x-www-form-urlencoded Body: { \"userID\": \"4c0c99ca5caef7c9f4707d641c726f55 \", \"AppEUI\": \"9816be466f467a17\", \"name\": \"test\" } Response Body: { \"code\": \"200\", \"message\": \"success\" }","title":"Application Register"},{"location":"Implementations/Server/#device-register","text":"This API is used for device register. POST /device Request Headers: Content-Type: application/x-www-form-urlencoded Body: { \"AppEUI\": \"9816be466f467a17\", \"DevEUI\": \"AAAAAAAAAAAAAAAA\", \"AppKey\": \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" } Response Body: { \"code\": \"200\", \"message\": \"success\" }","title":"Device Register"},{"location":"Implementations/Server/#gateway-register","text":"This API is used for gateway register. POST /gateway Request Headers: Content-Type: application/x-www-form-urlencoded Body: { \"userID\": \"4c0c99ca5caef7c9f4707d641c726f55 \", \"gatewayId\": \"bbbbbbbbbbbbbbbb\" } Response Body: { \"code\": \"200\", \"message\": \"success\" }","title":"Gateway Register"},{"location":"Implementations/Server/#issue-mac-commands","text":"This API is used to send the downlink MACCommand. POST /maccommand Request Headers: Content-Type: application/x-www-form-urlencoded Body: { \"DevAddr\": \"12345678 \", \"MACCommand\": \"030200ff01\" } Response Body: { \"code\": \"200\", \"message\": \"success\" } MAC Commands All the MAC Commands defined in LoRaWAN\u2122 1.1 are listed below. Bold font means the downlink MAC Commands. Cid MAC Command Payload Length(byte) 0x01 ResetInd Version 1 0x01 ResetConf Version 1 0x02 LinkCheckReq 0 0x02 LinkCheckAns Margin GwCnt 1 1 0x03 LinkADRReq TXPower ChMask Redundancy 1 2 1 0x03 LinkADRAns Status 1 0x04 DutyCycleReq DutyCyclePL 1 0x04 DutyCycleAns 0 0x05 RXParamSetupReq DLSettings Frequency 1 3 0x05 RXParamSetupAns Status 1 0x06 DevStatusReq 0 0x06 DevStatusAns Battery Margin 1 1 0x07 NewChannelReq ChIndex Freq DrRange 1 3 1 0x07 NewChannelAns Status 1 0x08 RXTimingSetupReq Settings 1 0x08 RXTimingSetupAns 0 0x09 TxParamSetupReq DwellTime 1 0x09 TxParamSetupAns 0 0x0A DlChannelReq ChIndex Freq 1 3 0x0A DlChannelAns Status 1 0x0B RekeyInd Version 1 0x0B RekeyConf Version 1 0x0C ADRParamSetupReq ADRParam 1 0x0C ADRParamSetupAns 0 0x0D DeviceTimeReq 0 0x0D DeviceTimeAns Seconds FractionalSec 4 1 0x0E ForceRejoinReq ForceRejoinReq 2 0x0F RejoinParamSetupReq RejoinParamSetupReq 1 0x0F RejoinParamSetupAns Status 1","title":"Issue MAC Commands"},{"location":"Implementations/Server/#error-list","text":"Code Message 2101 invalid email 2102 invalid password 2103 invalid AppEUI 2104 invalid DevEUI 2105 invalid AppKey 2106 invalid gatewayId 2107 invalid DevAddr 2108 invalid MACCommand 3101 user already registered 3102 user not registered 3103 user password error 3201 application already created 3202 application not created 3301 device already created 3401 gateway already created","title":"Error List"},{"location":"Tutorials/Application Integration/","text":"Application Integration Introduction This section describes how to integrate customized application servers into X-LoRa systems. Application Server is responsible for handling application payloads. It is necessary to support various applications with different encoding methods such as Protocol Buffer serialization to improve network transmission efficiency. Application Server also functions as a bridge between the cloud platform owned by users and the X-LoRa system so that customers can control LoRa devices and enjoy the applications through web browsers or APPs on smartphones. The IoT cloud can get the application payloads by subscribing the specific topic, and can also send downlink messages to the LoRa Server through the application server. Interaction with Server The data exchange format from Server to Application Server is defined in this section. Server to Application Server { DevAddr: <Buffer 00 08 fb 31>, FRMPayload: <Buffer c9 77 36 15>, }","title":"Application Integration"},{"location":"Tutorials/Application Integration/#application-integration","text":"","title":"Application Integration"},{"location":"Tutorials/Application Integration/#introduction","text":"This section describes how to integrate customized application servers into X-LoRa systems. Application Server is responsible for handling application payloads. It is necessary to support various applications with different encoding methods such as Protocol Buffer serialization to improve network transmission efficiency. Application Server also functions as a bridge between the cloud platform owned by users and the X-LoRa system so that customers can control LoRa devices and enjoy the applications through web browsers or APPs on smartphones. The IoT cloud can get the application payloads by subscribing the specific topic, and can also send downlink messages to the LoRa Server through the application server.","title":"Introduction"},{"location":"Tutorials/Application Integration/#interaction-with-server","text":"The data exchange format from Server to Application Server is defined in this section.","title":"Interaction with Server"},{"location":"Tutorials/Application Integration/#server-to-application-server","text":"{ DevAddr: <Buffer 00 08 fb 31>, FRMPayload: <Buffer c9 77 36 15>, }","title":"Server to Application Server"},{"location":"Tutorials/Configuration/","text":"Configuration The default configuration file is shown as follows. { \"database\": { \"mysql\": { \"username\": \"username\", \"password\": \"password\", \"database\": \"mysql\", \"host\": \"localhost\", \"port\": 3306, \"dialect\": \"mysql\", \"operatorsAliases\": false, \"logging\": false, \"timezone\": \"+08:00\", \"define\": { \"freezeTableName\": true, \"timestamp\": true, \"charset\": \"utf8\" }, \"pool\": { \"max\": 10, \"min\": 1, \"idle\": 10000, \"acquire\": 30000 } }, \"redis\": { \"cluster\": false, \"options\": [ { \"host\": \"localhost\", \"port\": 6379 } ] }, \"mongodb\": { \"host\": \"localhost\", \"port\": 27017, \"db\": \"loraLogger\", \"cluster\": false } }, \"mqClient_ns\": { \"consumerGroup\": { \"options\": { \"kafkaHost\": \"localhost:9092\", \"groupId\": \"lora-network-server-message-dispatch-in\", \"sessionTimeout\": 15000, \"protocol\": [ \"roundrobin\" ], \"fromOffset\": \"latest\" }, \"topics\": [ \"NS-sub\", \"AS-pub\", \"JS-pub\" ] }, \"client\": { \"kafkaHost\": \"localhost:9092\", \"clientId\": \"lora-network-server-message-dispatch-out\" }, \"producer\": { \"requireAcks\": 1, \"ackTimeoutMs\": 100, \"partitionerType\": 2 }, \"schemaPath\": { \"messages\": \"config/messages.json\", \"common\": \"config/common.json\" }, \"topics\": { \"pubToApplicationServer\": \"AS-sub\", \"subFromApplicationServer\": \"AS-pub\", \"pubToConnector\": \"NC-sub\", \"subFromConnector\": \"NS-sub\", \"pubToJoinServer\": \"JS-sub\", \"subFromJoinServer\": \"JS-pub\", \"pubToControllerServer\": \"CS-sub\", \"subFromControllerServer\": \"CS-pub\" } }, \"log\": { \"level\": \"debug\", \"colorize\": true }, \"server\": { \"fcntCheckEnable\": true, \"deduplication_Delay\": 200, \"downlink_Data_Delay\": 200 }, \"mqClient_js\": { \"consumerGroup\": { \"options\": { \"kafkaHost\": \"localhost:9092\", \"groupId\": \"lora-join-server-consumer\", \"sessionTimeout\": 15000, \"protocol\": [ \"roundrobin\" ], \"fromOffset\": \"latest\" }, \"topics\": [ \"JS-sub\" ] }, \"client\": { \"kafkaHost\": \"localhost:9092\", \"clientId\": \"lora-join-server-produce\" }, \"producer\": { \"requireAcks\": 1, \"ackTimeoutMs\": 100, \"partitionerType\": 2, \"joinServerTopic\": \"JS-pub\" } }, \"mqClient_nc\": { \"consumerGroup\": { \"options\": { \"kafkaHost\": \"localhost:9092\", \"groupId\": \"lora-network-connector-consumer\", \"sessionTimeout\": 15000, \"protocol\": [ \"roundrobin\" ], \"fromOffset\": \"latest\" }, \"topics\": [ \"NC-sub\" ] }, \"client\": { \"kafkaHost\": \"localhost:9092\", \"clientId\": \"lora-network-connector-produce\" }, \"producer\": { \"requireAcks\": 1, \"ackTimeoutMs\": 100, \"partitionerType\": 2 }, \"topics\": { \"pubToServer\": \"NS-sub\" } }, \"udp\": { \"port\": 1700 }, \"http\": { \"port\": 3000 }, \"mqClient_as\": { \"consumerGroup\": { \"options\": { \"kafkaHost\": \"localhost:9092\", \"groupId\": \"lora-application-server-message-dispatch-in\", \"sessionTimeout\": 15000, \"protocol\": [ \"roundrobin\" ], \"fromOffset\": \"latest\" }, \"topics\": [ \"AS-sub\", \"cloud-sub\" ] }, \"client\": { \"kafkaHost\": \"localhost:9092\", \"clientId\": \"lora-application-server-message-dispatch-out\" }, \"producer\": { \"requireAcks\": 1, \"ackTimeoutMs\": 100, \"partitionerType\": 2 }, \"schemaPath\": { \"messages\": \"config/messages.json\", \"common\": \"config/common.json\" }, \"topics\": { \"pubToCloud\": \"cloud-pub\", \"subFromCloud\": \"cloud-sub\", \"pubToServer\": \"AS-pub\", \"subFromServer\": \"AS-sub\" } }, \"mqClient_nct\": { \"consumerGroup\": { \"options\": { \"kafkaHost\": \"localhost:9092\", \"groupId\": \"lora-network-controller-message-dispatch-in\", \"sessionTimeout\": 15000, \"protocol\": [ \"roundrobin\" ], \"fromOffset\": \"latest\" }, \"topics\": [ \"CS-sub\" ] }, \"client\": { \"kafkaHost\": \"localhost:9092\", \"clientId\": \"lora-network-controller-message-dispatch-out\" }, \"producer\": { \"requireAcks\": 1, \"ackTimeoutMs\": 100, \"partitionerType\": 2 }, \"schemaPath\": { \"messages\": \"config/messages.json\", \"common\": \"config/common.json\" }, \"topics\": { \"pubToServer\": \"CS-pub\", \"subFromServer\": \"CS-sub\" } }, } In general, the following options are necessary for users to modify according to actual situations, database.mysql.username: the username of MySQL database.mysql.password: the user's password of MySQL database.mysql.database: the database used for X-LoRa in MySQL udp.port: the port for receiving UDP packets from LoRa Gateways(default value is 1700) http.port: the port of HTTP interfaces(default value is 3000) Other configurations are free to change to fit the environments.","title":"Configuration"},{"location":"Tutorials/Configuration/#configuration","text":"The default configuration file is shown as follows. { \"database\": { \"mysql\": { \"username\": \"username\", \"password\": \"password\", \"database\": \"mysql\", \"host\": \"localhost\", \"port\": 3306, \"dialect\": \"mysql\", \"operatorsAliases\": false, \"logging\": false, \"timezone\": \"+08:00\", \"define\": { \"freezeTableName\": true, \"timestamp\": true, \"charset\": \"utf8\" }, \"pool\": { \"max\": 10, \"min\": 1, \"idle\": 10000, \"acquire\": 30000 } }, \"redis\": { \"cluster\": false, \"options\": [ { \"host\": \"localhost\", \"port\": 6379 } ] }, \"mongodb\": { \"host\": \"localhost\", \"port\": 27017, \"db\": \"loraLogger\", \"cluster\": false } }, \"mqClient_ns\": { \"consumerGroup\": { \"options\": { \"kafkaHost\": \"localhost:9092\", \"groupId\": \"lora-network-server-message-dispatch-in\", \"sessionTimeout\": 15000, \"protocol\": [ \"roundrobin\" ], \"fromOffset\": \"latest\" }, \"topics\": [ \"NS-sub\", \"AS-pub\", \"JS-pub\" ] }, \"client\": { \"kafkaHost\": \"localhost:9092\", \"clientId\": \"lora-network-server-message-dispatch-out\" }, \"producer\": { \"requireAcks\": 1, \"ackTimeoutMs\": 100, \"partitionerType\": 2 }, \"schemaPath\": { \"messages\": \"config/messages.json\", \"common\": \"config/common.json\" }, \"topics\": { \"pubToApplicationServer\": \"AS-sub\", \"subFromApplicationServer\": \"AS-pub\", \"pubToConnector\": \"NC-sub\", \"subFromConnector\": \"NS-sub\", \"pubToJoinServer\": \"JS-sub\", \"subFromJoinServer\": \"JS-pub\", \"pubToControllerServer\": \"CS-sub\", \"subFromControllerServer\": \"CS-pub\" } }, \"log\": { \"level\": \"debug\", \"colorize\": true }, \"server\": { \"fcntCheckEnable\": true, \"deduplication_Delay\": 200, \"downlink_Data_Delay\": 200 }, \"mqClient_js\": { \"consumerGroup\": { \"options\": { \"kafkaHost\": \"localhost:9092\", \"groupId\": \"lora-join-server-consumer\", \"sessionTimeout\": 15000, \"protocol\": [ \"roundrobin\" ], \"fromOffset\": \"latest\" }, \"topics\": [ \"JS-sub\" ] }, \"client\": { \"kafkaHost\": \"localhost:9092\", \"clientId\": \"lora-join-server-produce\" }, \"producer\": { \"requireAcks\": 1, \"ackTimeoutMs\": 100, \"partitionerType\": 2, \"joinServerTopic\": \"JS-pub\" } }, \"mqClient_nc\": { \"consumerGroup\": { \"options\": { \"kafkaHost\": \"localhost:9092\", \"groupId\": \"lora-network-connector-consumer\", \"sessionTimeout\": 15000, \"protocol\": [ \"roundrobin\" ], \"fromOffset\": \"latest\" }, \"topics\": [ \"NC-sub\" ] }, \"client\": { \"kafkaHost\": \"localhost:9092\", \"clientId\": \"lora-network-connector-produce\" }, \"producer\": { \"requireAcks\": 1, \"ackTimeoutMs\": 100, \"partitionerType\": 2 }, \"topics\": { \"pubToServer\": \"NS-sub\" } }, \"udp\": { \"port\": 1700 }, \"http\": { \"port\": 3000 }, \"mqClient_as\": { \"consumerGroup\": { \"options\": { \"kafkaHost\": \"localhost:9092\", \"groupId\": \"lora-application-server-message-dispatch-in\", \"sessionTimeout\": 15000, \"protocol\": [ \"roundrobin\" ], \"fromOffset\": \"latest\" }, \"topics\": [ \"AS-sub\", \"cloud-sub\" ] }, \"client\": { \"kafkaHost\": \"localhost:9092\", \"clientId\": \"lora-application-server-message-dispatch-out\" }, \"producer\": { \"requireAcks\": 1, \"ackTimeoutMs\": 100, \"partitionerType\": 2 }, \"schemaPath\": { \"messages\": \"config/messages.json\", \"common\": \"config/common.json\" }, \"topics\": { \"pubToCloud\": \"cloud-pub\", \"subFromCloud\": \"cloud-sub\", \"pubToServer\": \"AS-pub\", \"subFromServer\": \"AS-sub\" } }, \"mqClient_nct\": { \"consumerGroup\": { \"options\": { \"kafkaHost\": \"localhost:9092\", \"groupId\": \"lora-network-controller-message-dispatch-in\", \"sessionTimeout\": 15000, \"protocol\": [ \"roundrobin\" ], \"fromOffset\": \"latest\" }, \"topics\": [ \"CS-sub\" ] }, \"client\": { \"kafkaHost\": \"localhost:9092\", \"clientId\": \"lora-network-controller-message-dispatch-out\" }, \"producer\": { \"requireAcks\": 1, \"ackTimeoutMs\": 100, \"partitionerType\": 2 }, \"schemaPath\": { \"messages\": \"config/messages.json\", \"common\": \"config/common.json\" }, \"topics\": { \"pubToServer\": \"CS-pub\", \"subFromServer\": \"CS-sub\" } }, } In general, the following options are necessary for users to modify according to actual situations, database.mysql.username: the username of MySQL database.mysql.password: the user's password of MySQL database.mysql.database: the database used for X-LoRa in MySQL udp.port: the port for receiving UDP packets from LoRa Gateways(default value is 1700) http.port: the port of HTTP interfaces(default value is 3000) Other configurations are free to change to fit the environments.","title":"Configuration"},{"location":"Tutorials/Installation of LoRa Web Server/","text":"Installation of LoRa Web Server This section describes the installation of LoRa Web Server. System Requiremwnts All the requirements below should be met before installing the LoRa web server. Apache (version: 2.4.* recommend: 2.4.7) PHP (version>=7.0.0 recommend: 7.0.30) MySQL (version>=5.7 recommend: 5.7) MongoDB (recommend: 3.4.9) Composer (recommend: 1.5.2) Getting Started Clone this repo into a directory: git clone https://github.com/xisiot/lora-web-server cd lora-web-server Install dependencies by using composer install : composer install Copy a local . env from .env.example : cp .env.example .env Run php artisan key:generate to generate the app key in .env file. php artisan key:generate Modify the configurations of MySQL, MongoDB and the registration interface URL in . env file. The detailed configurations are described as follows: // the configuration of the database(MySQL) DB_CONNECTION=mysql // the host of the database DB_HOST=127.0.0.1 // the port of the database DB_PORT=3306 // the name of the database DB_DATABASE= // the username DB_USERNAME= // the password DB_PASSWORD= //registration interface provided by lora server,the default is http://localhost:3000 HTTP_URL=http://localhost:3000 // the configuration of the database(MongoDB) MONGO_HOST=127.0.0.1 MONGO_PORT=27017 // the name of the Mongo database MONGO_DB= Perform database migration by using php artisan migrate : php artisan migrate Run the artisan command to start the LoRa web server system directly : php artisan serve --host=0.0.0.0 --port=8000 Self-starting the web needs to do the following operations: Ubuntu 14.04 Add the xxx.conf file to the /etc/init directory and modify the configurations about the project path, log, upstart commands, and so on. The detailed configurations are described as follows: # lora-web-server config # a web management system for lora-web-server # this is a upstart conf file # lora-web-server name can be modified, # this is the name of the self-started service description \" lora-web-server \" # no configuration required start on runlevel [2345] stop on shutdown respawn respawn limit 10 5 # configuration content that needs to be modified script PHP=`which php` # the directory of the Laravel project PROJECT_PATH='/XXX/XXX/lora-web-server ' # the directory of the log of the Laravel project LOG_PATH='/XX/XX/lora-web-server/storage/logs/laravel.log' # upstart host name, set to local HOST='0.0.0.0' # the port number of the web page, # ensure that it is not occupied by other service. PORT=8000 # no configuration required LOG_DIR=`dirname $LOG_PATH` [[ -d $LOG_DIR ]] || mkdir -p $LOG_PATH # no configuration required exec $PHP \"$PROJECT_PATH/artisan\" serve --host $HOST --port $PORT >> $LOG_PATH 2>&1 end script Run the following command to start the LoRa web server system : service lora-web-server start Ubuntu 16.04 Add the upstart script to the /usr/sbin/ directory and write the absolute path to the lora-web-server.service file in /lib/systemd/system/ directory: #!/bin/sh XXX stand for the absolute path of the laravel project php /XXX/XXX/lora-web-server /artisan serve --host 0.0.0.0 --port 8000 #the XXXX after the port indicates the port number of the web page startup. Add the lora-web-server.service file to /lib/systemd/system/ directory : [Unit] Description= lora-web-server [Service] #Type=forking #User=root #the specific shell execution file of the service process, #xxx is the file name, not the folder name ExecStart=/usr/sbin/lora-web-server #here is the startup configuration file under the /usr/sbin/ path above. PrivateTmp=true [Install] WantedBy=multi-user.target Run the following command to start the LoRa web server system : systemctl start lora-web-server.service","title":"Installation of LoRa Web Server"},{"location":"Tutorials/Installation of LoRa Web Server/#installation-of-lora-web-server","text":"This section describes the installation of LoRa Web Server.","title":"Installation of LoRa Web Server"},{"location":"Tutorials/Installation of LoRa Web Server/#system-requiremwnts","text":"All the requirements below should be met before installing the LoRa web server. Apache (version: 2.4.* recommend: 2.4.7) PHP (version>=7.0.0 recommend: 7.0.30) MySQL (version>=5.7 recommend: 5.7) MongoDB (recommend: 3.4.9) Composer (recommend: 1.5.2)","title":"System Requiremwnts"},{"location":"Tutorials/Installation of LoRa Web Server/#getting-started","text":"Clone this repo into a directory: git clone https://github.com/xisiot/lora-web-server cd lora-web-server Install dependencies by using composer install : composer install Copy a local . env from .env.example : cp .env.example .env Run php artisan key:generate to generate the app key in .env file. php artisan key:generate Modify the configurations of MySQL, MongoDB and the registration interface URL in . env file. The detailed configurations are described as follows: // the configuration of the database(MySQL) DB_CONNECTION=mysql // the host of the database DB_HOST=127.0.0.1 // the port of the database DB_PORT=3306 // the name of the database DB_DATABASE= // the username DB_USERNAME= // the password DB_PASSWORD= //registration interface provided by lora server,the default is http://localhost:3000 HTTP_URL=http://localhost:3000 // the configuration of the database(MongoDB) MONGO_HOST=127.0.0.1 MONGO_PORT=27017 // the name of the Mongo database MONGO_DB= Perform database migration by using php artisan migrate : php artisan migrate Run the artisan command to start the LoRa web server system directly : php artisan serve --host=0.0.0.0 --port=8000 Self-starting the web needs to do the following operations: Ubuntu 14.04 Add the xxx.conf file to the /etc/init directory and modify the configurations about the project path, log, upstart commands, and so on. The detailed configurations are described as follows: # lora-web-server config # a web management system for lora-web-server # this is a upstart conf file # lora-web-server name can be modified, # this is the name of the self-started service description \" lora-web-server \" # no configuration required start on runlevel [2345] stop on shutdown respawn respawn limit 10 5 # configuration content that needs to be modified script PHP=`which php` # the directory of the Laravel project PROJECT_PATH='/XXX/XXX/lora-web-server ' # the directory of the log of the Laravel project LOG_PATH='/XX/XX/lora-web-server/storage/logs/laravel.log' # upstart host name, set to local HOST='0.0.0.0' # the port number of the web page, # ensure that it is not occupied by other service. PORT=8000 # no configuration required LOG_DIR=`dirname $LOG_PATH` [[ -d $LOG_DIR ]] || mkdir -p $LOG_PATH # no configuration required exec $PHP \"$PROJECT_PATH/artisan\" serve --host $HOST --port $PORT >> $LOG_PATH 2>&1 end script Run the following command to start the LoRa web server system : service lora-web-server start Ubuntu 16.04 Add the upstart script to the /usr/sbin/ directory and write the absolute path to the lora-web-server.service file in /lib/systemd/system/ directory: #!/bin/sh XXX stand for the absolute path of the laravel project php /XXX/XXX/lora-web-server /artisan serve --host 0.0.0.0 --port 8000 #the XXXX after the port indicates the port number of the web page startup. Add the lora-web-server.service file to /lib/systemd/system/ directory : [Unit] Description= lora-web-server [Service] #Type=forking #User=root #the specific shell execution file of the service process, #xxx is the file name, not the folder name ExecStart=/usr/sbin/lora-web-server #here is the startup configuration file under the /usr/sbin/ path above. PrivateTmp=true [Install] WantedBy=multi-user.target Run the following command to start the LoRa web server system : systemctl start lora-web-server.service","title":"Getting Started"},{"location":"Tutorials/Installation/","text":"Installation There are two methods to deploy an X-LoRa system, i.e., installation with repositories or with Docker. Installation with Repositories System Requirements It is necessary for users to make sure that all the prerequisites below have been installed before deploying X-LoRa from repositories. Node.js (version >= 8) MySQL (version >=5.6) Redis Kafka MongoDB Getteing Started After installing the required software, please follow the steps below to configure the environments. Create a new database in MySQL. Start Kafka, Redis and MongoDB in the background. Clone this repo into a directory: git clone https://github.com/xisiot/lora-system.git --recursive cd lora-system Install all Node.js dependencies by using npm install . Copy a local config.json from config_template.json : cp config_template.json config.json Modify the configurations of kafka, MySQL and other customized fields in config.json . The detailed configurations are described in Section 2.2. Use start.sh to start LoRa system: ./start.sh To test if the system has started properly, please refer to: Motes Emulator . Installation with Docker System Requiremwnts It is necessary for users to make sure that all the prerequisites below have been installed before deploying X-LoRa from Docker. Docker Getting Started After successful installation of Docker, please follow the steps below: Pull the xisiot/lora-system docker image: docker pull xisiot/lora-system:latest Run the xisiot/lora-system image in a container and map the port of 1700 to the container\u2019s published port 1700 using option -p : docker run -it --name=\"test\" -p 1700:1700/udp -p 3000:3000/tcp xisiot/lora-system:latest /bin/bash Start MySQL, Redis, MongoDB and Kafka in the background: service mysql start redis-server & mongod -config /etc/mongod.conf & cd root/kafka ./bin/zookeeper-server-start.sh -daemon config/zookeeper.properties ./bin/kafka-server-start.sh -daemon config/server.properties No more configurations need to be changed in this installation process. Use start.sh to start LoRa system: cd ../lora/lora-system ./start.sh To test if the system has started properly, please refer to: Motes Emulator .","title":"Installation"},{"location":"Tutorials/Installation/#installation","text":"There are two methods to deploy an X-LoRa system, i.e., installation with repositories or with Docker.","title":"Installation"},{"location":"Tutorials/Installation/#installation-with-repositories","text":"","title":"Installation with Repositories"},{"location":"Tutorials/Installation/#system-requirements","text":"It is necessary for users to make sure that all the prerequisites below have been installed before deploying X-LoRa from repositories. Node.js (version >= 8) MySQL (version >=5.6) Redis Kafka MongoDB","title":"System Requirements"},{"location":"Tutorials/Installation/#getteing-started","text":"After installing the required software, please follow the steps below to configure the environments. Create a new database in MySQL. Start Kafka, Redis and MongoDB in the background. Clone this repo into a directory: git clone https://github.com/xisiot/lora-system.git --recursive cd lora-system Install all Node.js dependencies by using npm install . Copy a local config.json from config_template.json : cp config_template.json config.json Modify the configurations of kafka, MySQL and other customized fields in config.json . The detailed configurations are described in Section 2.2. Use start.sh to start LoRa system: ./start.sh To test if the system has started properly, please refer to: Motes Emulator .","title":"Getteing Started"},{"location":"Tutorials/Installation/#installation-with-docker","text":"","title":"Installation with Docker"},{"location":"Tutorials/Installation/#system-requiremwnts","text":"It is necessary for users to make sure that all the prerequisites below have been installed before deploying X-LoRa from Docker. Docker","title":"System Requiremwnts"},{"location":"Tutorials/Installation/#getting-started","text":"After successful installation of Docker, please follow the steps below: Pull the xisiot/lora-system docker image: docker pull xisiot/lora-system:latest Run the xisiot/lora-system image in a container and map the port of 1700 to the container\u2019s published port 1700 using option -p : docker run -it --name=\"test\" -p 1700:1700/udp -p 3000:3000/tcp xisiot/lora-system:latest /bin/bash Start MySQL, Redis, MongoDB and Kafka in the background: service mysql start redis-server & mongod -config /etc/mongod.conf & cd root/kafka ./bin/zookeeper-server-start.sh -daemon config/zookeeper.properties ./bin/kafka-server-start.sh -daemon config/server.properties No more configurations need to be changed in this installation process. Use start.sh to start LoRa system: cd ../lora/lora-system ./start.sh To test if the system has started properly, please refer to: Motes Emulator .","title":"Getting Started"},{"location":"Tutorials/Usage/","text":"Usage This section describes the detailed instructions of X-LoRa. It shows how to create applications, register gateways and activate devices. Registration on LoRa Web Users need to register their applications, gateways and devices on the LoRa web before further operations. User Management Create an account for the LoRa web and start enjoying the service the LoRa server provided. With a LoRa web account, the following can be done: Creating applications, gateways and devices Easy access to the transmission data and application data It's necessary to fill in the following fields when register an account. Note that the password field requires at least 6 characters long. TABLE 1 Description of User Registration Form Field Type Description Attribute Name String User's name Required E-mail Address String User's email Required Password String User's password Required Gateway Management LoRa gateways directly connect to LoRa network connector and upload and download data for LoRa devices. However, registering gateway in the LoRa web is firstly needed. The verification of the existence of the gateways without registering in the LoRa web can\u2019t success. The fields in the following table need to be filled in during the registration of gateways. Note that the gatewayID field should be unique. If not, the registration can\u2019t be successful. Once the registration is successful, the web will return a list of gateways that the user has registered. TABLE 2 Description of Gateway Registration Form Field Type Description Attribute gatewayID String Gateway MAC address Unique type String Indoor/Outdoor Required frequency plan Number Frequency Required model String X01/X02/X03 Required location String Gateway location Required Application Management Each device belongs to a certain application. Therefore, before registering devices, users should register applications first. The fields in the following table need to be filled in during the registration of applications. Note that the AppEUI field should be unique. If not, the registration can\u2019t be successful. Once the registration is successful, the web will return a list of applications that the user has registered. TABLE 3 Description of Application Registration Form Field Type Description Attribute Application Name String Application name Required AppEUI String LoRa\u2122 application unique identifier Unique Device Management Before LoRa devices are able to connect to the LoRa server, users should register them in the LoRa web. Without that, the verification of the existence of the devices will fail. Device registration must be performed after the application is registered, which has been explained in the previous section. Due to the fact that activation of an end-device can be achieved in two ways, device registration can be divided into two categories, i.e., Over-The-Air Activation (OTAA) and Activation by Personalization (ABP) modes. The attribute fields required for the registration of the two modes have different requirements, i.e., OTAA Mode The fields in the following table need to be filled in during the registration of devices. Note that the DevEUI field should be unique. If not, the registration can\u2019t be successful. Once the registration is successful, the web will return a list of devices that the user has registered. TABLE 4 Description of OTAA Device Registration Form Field Type Description Attribute DevEUI String LoRa device unique identifier Unique AppKey String AES-128 application key Required ABP Mode The fields in the following table need to be filled in during the registration of devices. Note that the DevEUI field and DevAddr field should be unique. If not, the registration can\u2019t be successful. Once the registration is successful, the web will return a list of devices that the user has registered. TABLE 5 Description of ABP Device Registration Form Field Type Description Attribute DevEUI String LoRa device unique identifier Unique AppKey String AES-128 application key Required DevAddr String LoRa device unique address Unique NwkSKey String Network session key Required AppSKey String Application session key Required Interaction with LoRa Server For over-the-air activation, LoRa devices must follow a join procedure prior to participating in data exchanges with the Network Server. An end-device has to go through a new join procedure every time when it has lost the session context information. After that, devices can send the uplink messages and receive the downlink messages from the LoRa server. Activating a LoRa devices by personalization means that all the necessary information is stored in devices in the very beginning. These devices can interact with LoRa server directly.","title":"Usage"},{"location":"Tutorials/Usage/#usage","text":"This section describes the detailed instructions of X-LoRa. It shows how to create applications, register gateways and activate devices.","title":"Usage"},{"location":"Tutorials/Usage/#registration-on-lora-web","text":"Users need to register their applications, gateways and devices on the LoRa web before further operations.","title":"Registration on LoRa Web"},{"location":"Tutorials/Usage/#user-management","text":"Create an account for the LoRa web and start enjoying the service the LoRa server provided. With a LoRa web account, the following can be done: Creating applications, gateways and devices Easy access to the transmission data and application data It's necessary to fill in the following fields when register an account. Note that the password field requires at least 6 characters long. TABLE 1 Description of User Registration Form Field Type Description Attribute Name String User's name Required E-mail Address String User's email Required Password String User's password Required","title":"User Management"},{"location":"Tutorials/Usage/#gateway-management","text":"LoRa gateways directly connect to LoRa network connector and upload and download data for LoRa devices. However, registering gateway in the LoRa web is firstly needed. The verification of the existence of the gateways without registering in the LoRa web can\u2019t success. The fields in the following table need to be filled in during the registration of gateways. Note that the gatewayID field should be unique. If not, the registration can\u2019t be successful. Once the registration is successful, the web will return a list of gateways that the user has registered. TABLE 2 Description of Gateway Registration Form Field Type Description Attribute gatewayID String Gateway MAC address Unique type String Indoor/Outdoor Required frequency plan Number Frequency Required model String X01/X02/X03 Required location String Gateway location Required","title":"Gateway Management"},{"location":"Tutorials/Usage/#application-management","text":"Each device belongs to a certain application. Therefore, before registering devices, users should register applications first. The fields in the following table need to be filled in during the registration of applications. Note that the AppEUI field should be unique. If not, the registration can\u2019t be successful. Once the registration is successful, the web will return a list of applications that the user has registered. TABLE 3 Description of Application Registration Form Field Type Description Attribute Application Name String Application name Required AppEUI String LoRa\u2122 application unique identifier Unique","title":"Application Management"},{"location":"Tutorials/Usage/#device-management","text":"Before LoRa devices are able to connect to the LoRa server, users should register them in the LoRa web. Without that, the verification of the existence of the devices will fail. Device registration must be performed after the application is registered, which has been explained in the previous section. Due to the fact that activation of an end-device can be achieved in two ways, device registration can be divided into two categories, i.e., Over-The-Air Activation (OTAA) and Activation by Personalization (ABP) modes. The attribute fields required for the registration of the two modes have different requirements, i.e., OTAA Mode The fields in the following table need to be filled in during the registration of devices. Note that the DevEUI field should be unique. If not, the registration can\u2019t be successful. Once the registration is successful, the web will return a list of devices that the user has registered. TABLE 4 Description of OTAA Device Registration Form Field Type Description Attribute DevEUI String LoRa device unique identifier Unique AppKey String AES-128 application key Required ABP Mode The fields in the following table need to be filled in during the registration of devices. Note that the DevEUI field and DevAddr field should be unique. If not, the registration can\u2019t be successful. Once the registration is successful, the web will return a list of devices that the user has registered. TABLE 5 Description of ABP Device Registration Form Field Type Description Attribute DevEUI String LoRa device unique identifier Unique AppKey String AES-128 application key Required DevAddr String LoRa device unique address Unique NwkSKey String Network session key Required AppSKey String Application session key Required","title":"Device Management"},{"location":"Tutorials/Usage/#interaction-with-lora-server","text":"For over-the-air activation, LoRa devices must follow a join procedure prior to participating in data exchanges with the Network Server. An end-device has to go through a new join procedure every time when it has lost the session context information. After that, devices can send the uplink messages and receive the downlink messages from the LoRa server. Activating a LoRa devices by personalization means that all the necessary information is stored in devices in the very beginning. These devices can interact with LoRa server directly.","title":"Interaction with LoRa Server"}]}